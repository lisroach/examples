	For this project we were required to use a quick sort and a heap sort. Quick sorts have a 
worts case time complexity of O(n^2), but an average time of O(nlogn). As you can see from the 
testing, quicksort is often the fastest of the sorts. Heap sort has am average and wprst case time 
of nlogn. When choosing my third sort, I went with merge sort. This is because merge sort has a 
better worst case time complexity than quick sort, and the same average time complexity as the 
other two sorts (nlogn). Additionally, merge sort is stable. I had hoped to implement a natural 
merge sort, which would utilize already created lists in order to merge those automatically and 
save some time and space. I had a few bugs with the code, so I went with a standard 
implementation, but I believe a natural merge sort would have helped gain some time for the longer 
lists. As it is now, my merge sort is not ofetn faster than the other two lists. I think with a 
better implementation, merge sort could on average perform better than the other two sorts.
	For testing this, I created random list of the following data types: integers, doubles, 
string, and class objects. To do this I used the rand() function, which generates random numbers. 
For each datatype I randomly determined the size of the list using rand(), and for string I also 
randomly chose the length of each string in order to have a variety of lists. To test class 
objects, a very small class called helloWorld was created, with overloaded <  and > operators so 
that comparisons could be made between types. All the lists were stored as vector as was required 
by the project charge. 
	To call the lists on the same data was pretty simple, I just stored the data in different 
vectors by datatype and called the three function calls on the datatypes in order. Sometimes with 
smaller strings the time would be so small as to appear to be 0, but each test of a datatype was 
run 10 different times in order to gather enough data to ensure an accurate average time.
	The overall running time of the whole program was O(RAND_MAX^9logRAND_MAX^2). RAND_MAX is 
the highset number that the rand() function can generate. A more easily readable format is 
O(n^9logn^2). This is quite large, but there this is a large program and no one piece is taking up 
a large amount of time. The space complexity is small, with O(n^2) generated by the sorts, and 
more space taken by the generation of the vectors. 
